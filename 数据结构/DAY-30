	**KMP算法** 
	母串的指针不需要回溯
	a  e  a  d  a  e  a  d  a  e  a  e
	-1 -1 0  -1 0  1  2  3  4  5  6  1   **尽可能的找最长的子串**
	
	**Sunday算法**  最优时间为 n/ m (m为模式串)
	**NFA**   非确定性有穷自动机
	**SHIFT-AND算法** P 记录匹配是否成功 Pi->j 截止母串i位置,模式串前j位能否匹配成功
	p = (p << 1 | 1) & d[s[i]]
	p & (a << (n - 1)) ?= 1
	a  e  c  a  e  a  e  c  a  e  d
	                  0  0  1  0  0
	                  0  1  0  0  0
	                  0  0  0  0  1
	                  1  0  0  0  0
	
	
	p = 1 & 0001 = 000001;
	p = 0010 & 0010 = 000010;
	p = 0100 & 0100 = 000100;
	p = 1000 & 1000 = 001000;
	p = 0 & 0001 = 0001;
	
	shift-and 处理任意长度的;
<>
	
	**字典树**
	节点是集合, 字母全在边上  (网上的字母全在节点上)
	
	**哈希树**  哈希套哈希
	**哈希树的特例是字典树**
	**二叉树与哈弗曼树**
	**双数组字典树**
	串行化与反串行化与随机访问, 贼方便,(串行化不管在哪台机器跑都可以得出一样的结果)
	坐标, bool, 数值  (当负值没有用的时候) 数组可以存储三类信息
	
	
	**AC自动机**   结合了KMP与字典树的精髓   比字典树多了一个失败指针
	根据当前输入选择下一个状态
	作业 1.用二叉字典树加哈弗曼树实现对任意信息的索引及查找
	     2.建立双数组字典树AC自动机
	     3.计算客 + leetcode + 面试
	     4.做阶段性总结
