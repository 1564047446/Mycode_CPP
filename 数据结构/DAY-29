
	**二分查找**  
	这类问题最小最大解 0 或 1 表示能或不能
	1 1 1 1 0 0 0 最后一个出现的1  mid = (head + tail + 1) >> 1;
									head = mid ;
									tail = mid - 1;
									
	0 0 0 1 1 1 1 第一个出现的1     最小花费
	tail = right - 1;
	if a[mid] == 1, head = mid + 1;
	if a[mid] != 1 tail = mid
	
	
	**三分查找**
	
	**哈希表**  从高维空间到低维空间的映射
	zobrast hash 
	
	字符串很在乎字符串的顺序信息
	bkdr hash   不能是2的倍数, 否则末尾若干相等  数值运算比较优秀
	ap hash

	**步进二分**    +1 +2 +4 +8 +16

	leetcode 03 杨氏矩阵  二分的性质去缩小区间, 站在一个点一边全部比他大, 另一边全部比他小,然后去找
	把低维的空间化成高维的空间去思考问题 
	用hash拿空间换时间

	**双数组中位数**
	A  n
	B  m
	k = (n + m) / 2;
	每个数组找到 k / 2 最小的, 扔掉
	直到找到第K个数字
	leetcode 136, 389, 137, 260, 371, 191, 190

	取最低位为1 x = x &(-x)
	a = a ^ b;
	b = a (a & b) << 1;
	test98.cpp 统计一个数字中1的个数(__builtin_popcount(n)) 
	x = ((x&0xAAAAAAAA)>>1) + (x & 0x33333333)

	
