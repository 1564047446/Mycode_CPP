		第一课
	
	类型 = 类型数据 + 类型操作
        
	**类 = 类数据 + 类操作**
	& 左值引用
	&& 右值引用
	
	**构造函数**
	没有返回值 连void都没有返回, 和类名同名， 不会造成语法歧义。
	在类里的静态方法就是类方法 this是指针， 存的成员地址
	const 方法 不去修改this对象中任何属性的值 
	引用：叫法不同， 但是是同一个对象
	类里存由虚函数表
	struct 访问权限默认 public
	class 访问权限默认 private
	
	对象的初始化： 1 开辟对象数据区 -> 2 匹配构造函数 -> 3完成构造
	对象的拷贝  ： 1 开辟对象数据区 -> 2 匹配拷贝构造函数 -> 3 完成构造  如果不是引用的话 会死循环下去	
	返回值优化  ： 直接用左值引用
	关闭返回值优化 -fno-elide-constructors;
		
	**析构函数**
	~func()

		第二课
		
	static int 静态存储区  如果在类里不会为类开辟这样的一个内存， 他会开在静态存储区里
	
	封装， 继承， 多态
	
	**继承**
	父类， 子类， -> 基类， 派生类
	
	子类的数据存在父类的数据里 (先开辟父类空间， 初始化父类)
	
	实验： 
	1.父类 struct 子类 class 
	2.父类 struct 子类 struct
	3.父类 class 子类 class
	4.父类class 子类 struct
	
	类外部定义子类对象 访问
	
	父类的构造必须在子类的构造列表中
	
	1.开辟两块存储区 -> 2. 匹配子类构造函数 -> 3.匹配父类构造函数 - > 4.完成父类构造过程 -> 5.完成子类构造过程
	拷贝构造函数   显示调用父类拷贝构造
	
	**菱形继承**
	
	杜绝菱形继承
	
	new 操作符会调用构造函数

		第三课
	
	**多态** 
	
	子类函数无法覆盖父类函数
	多态和虚函数相关
	虚函数是跟着对象走的
	纯虚函数  virtual a() = 0; 相当于方法根本没有定义
	如果基类有纯虚函数，相关派生类必须进行实现
	具有纯虚方法的类叫做抽象类， 抽象类不能生成对象


		第四课

	**自学lambda表达式**
	修改代码中的强制类型转换的方式， 改成C++风格的类型转换
	自学lambda表达式， 下堂课进行同意讲解

	**this关键字**	是有类型的
	
	
	mutable  多变的  可以修改const的变量

	**大小端**
	数据的低位是怎么存的， 小端低地址存低位， 大端低地址存高位
	
	
	
	
	
	**左值引用和有值引用**
	例如  ++i 和 i++ (分别类比左值引用和有值引用) ++i 出了这行代码还可以访问， i++出了这行代码不可访问， 相当于一个临时值。
	
	**访问者模式**
	根据对象不同执行不同的方法
	增加一种需求 等于增加一种类
	
	
	
	
	
	
